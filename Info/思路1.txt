题意：给定一个有向图，求出图中所有长度在[3,7]之间的环。

输入：格式为[IDU,IDV,~]的边表，ID为32位无符号整数（当然题目说明了，小于2^31，所以int32就好），边最多28W条，不重复，结点平均度数小于10。环中同一个ID不可以重复出现（若大环包括小环，则需要分开统计），环的个数不大于300W。

输出：环的个数，按照1.环长度；2.环的数字字典序输出所有环。

举个例子：1,2,3的全连接图有两个环

初步思路（Updated on 200407）：

要避免搜索出的路径重复，需要制定一个环的标准型，以题目为例，就是最小的ID在环表示的首位
题目要求最小的结点在每个路径的第一位，故对ID排序后，重映射所有结点序号为[0,n)，在搜索时，如果直接对某个结点的出边从小到大搜索，最后得到的答案自然是排好序的（虽然排序一遍答案花掉的时间也不多）
用拓扑排序删去一部分点（入度为0，或出度为0的点可以删去，直到没有满足条件的点）
搜索，剪枝（深度在3-7之间、每次访问的结点ID都应该大于起点的ID），这里有很大的优化空间
关于换行应该是CRLF（\r\n）还是LF（\n），官方表示都没有关系
先贴一个在100万环【E28W N30000 A1004812】的数据集上要跑几分钟的Baseline，不保证完全正确（仅供思路参考，不要拿去提交哦）

https://paste.ubuntu.com/p/3gBwyNbw2w/
​
paste.ubuntu.com
在极限情况下，IO的耗时（主要是输出文件比较大）若使用ofstream大概在8s左右（这时间比大佬跑两次还要慢QAQ），使用fwrite大概在3s左右（文件~240MB），主要时间还是耗费在答案的寻找上

改进思路：

问题的更优解法
并行求解，平台代码优化（评测姬4C16G）
IO优化
初步优化思路（Updated on 200407）：

大佬们总是在炫耀运行时间，让我们这种菜鸡情何以堪

在暴力膜的基础上，该如何进行优化？

通过观察不难发现，在比较稠密的图上，长度为N的环的数量相比长度为N-1的环的数量是指数增长的（和结点的平均度数有关）。

如果能通过只搜索到第6层，而非第7层就得到所有的解，就能够将运行的时间有效的缩减到原先的1/4左右。

我们定义如下的数据结构：

vector<unordered_map<int,vector<int>>> P2;

使用P2[i][j][k]来表示结点i到达结点j，中间经过结点k的路径详情，如果k不在我们已经搜索过的节点列表中，并且j是起点，那么i-k-j就是符合要求的路径的一部分。

具体来说，就是提前做深度为2的搜索（保存最后一层节点的入边），在第6层时直接根据现有结果进行判断，不进入第七层。

按照这个Naive的思路来进行优化，我们可以得到如下的解决方案：

Ubuntu Pastebin
​
paste.ubuntu.com
代码实现的复杂度是和节点数相关的（主要是作者写的太挫了），在一些自制的测试数据集上，算法的单线程表现为：

E28W N30000 A1004812 61s
E28W N25700 A2896262 69s
E28W N25000 A3512444 77s


为了防止世界被破坏，正式提交开始后，不再提供代码分享。



欢迎大佬们私信、留言来交流指点解题思路。